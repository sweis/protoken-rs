# Research: Subject Identifiers in Token Systems

Analysis of how `sub` (subject) and `aud` (audience) identifiers are represented
across token/identity systems, and tradeoffs for protoken-rs.

## 1. JWT `sub` Claim (RFC 7519)

**Format:** `StringOrURI` -- a case-sensitive string where any value containing a `:`
must be a valid URI per RFC 3986. No maximum length specified in the RFC itself.

**Uniqueness:** Must be locally unique within the issuer's context, or globally unique.
The RFC says `sub` + `iss` together should identify a principal.

**Usage:** Optional. In OAuth 2.0 profiles (RFC 7523), `sub` is mandatory and identifies
the resource owner or the OAuth `client_id`.

**In practice:** Providers use wildly different formats:
- Google: numeric string, ~21 digits (e.g., `"107145139691231222712"`)
- Auth0: `provider|id` format (e.g., `"auth0|507f1f77bcf86cd799439011"`)
- Microsoft: 43-char base64url string (pairwise SHA-256 hash)
- Custom systems: UUIDs, email addresses, usernames, opaque IDs

**Key takeaway:** RFC 7519 imposes almost no constraints. The `sub` is an opaque string
whose format is entirely application-defined.

References:
- [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)
- [RFC 7523 - JWT Profile for OAuth 2.0](https://www.rfc-editor.org/rfc/rfc7523.html)

## 2. OpenID Connect `sub`

**Format:** String, max 255 ASCII characters (OIDC Core 1.0 Section 5.7).

**Uniqueness:** Locally unique per issuer, never reassigned. The spec states:
*"The only guaranteed unique identifier for a given End-User is the combination of
the `iss` Claim and the `sub` Claim."*

**Subject Identifier Types:**
- **Public:** Same `sub` for a user across all clients (Google uses this).
- **Pairwise:** Different `sub` per client application, preventing cross-client
  correlation (Microsoft uses this). Generated by hashing user ID + app ID + salt.

**Provider formats:**
| Provider   | Format                          | Length   | Type     |
|------------|---------------------------------|----------|----------|
| Google     | Numeric string                  | ~21 chars| Public   |
| Microsoft  | Base64url SHA-256 hash          | 43 chars | Pairwise |
| Auth0      | `provider\|id`                  | Variable | Public   |
| Okta       | Opaque alphanumeric             | ~20 chars| Public   |

**Key takeaway:** 255-byte max. In practice, most providers use 20-50 bytes. Pairwise
identifiers are derived hashes, not stored user IDs.

References:
- [OpenID Connect Core 1.0 Section 8](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes)
- [Google OIDC](https://developers.google.com/identity/openid-connect/openid-connect)
- [Microsoft ID Token Claims](https://learn.microsoft.com/en-us/entra/identity-platform/id-token-claims-reference)

## 3. SAML NameID

SAML subjects use typed `<NameID>` elements with explicit format URIs:

| Format                  | Value Example                        | Use Case        |
|-------------------------|--------------------------------------|-----------------|
| `persistent`            | Opaque hash (like OIDC pairwise)     | Cross-session   |
| `transient`             | Random per-session ID, max 256 chars | Anonymous/temp  |
| `emailAddress`          | `user@example.com`                   | Most common     |
| `unspecified`           | Anything                             | Fallback        |
| `X509SubjectName`       | `CN=John Doe,O=Example`             | Certificate DN  |
| `kerberos`              | `user@REALM`                         | Kerberos        |
| `WindowsDomainQualified`| `DOMAIN\user`                        | Windows AD      |

**Key takeaway:** SAML explicitly types its identifiers. The most common real-world format
is email address, but persistent (opaque hash) is the most robust. This is the only system
that formally separates the *format* of the identifier from its *value*.

References:
- [SAML 2.0 Core, Section 8.3](http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf)
- [SAML Subject Identifier Attributes Profile v1.0](https://docs.oasis-open.org/security/saml-subject-id-attr/v1.0/cs01/saml-subject-id-attr-v1.0-cs01.html)

## 4. RFC 9493: Structured Subject Identifiers

RFC 9493 (Dec 2023) formalizes structured subject identifiers for Security Event Tokens.
It defines a `sub_id` JWT claim (a JSON object, not a string) with registered formats:

| Format       | Example Value                                           |
|--------------|---------------------------------------------------------|
| `account`    | `{"format":"account","uri":"acct:user@example.com"}`    |
| `email`      | `{"format":"email","email":"user@example.com"}`         |
| `iss_sub`    | `{"format":"iss_sub","iss":"https://idp.example.com","sub":"abc123"}` |
| `opaque`     | `{"format":"opaque","id":"11235813213455"}"`             |
| `phone_number`| `{"format":"phone_number","phone_number":"+12065551234"}` |
| `did`        | `{"format":"did","url":"did:example:123456"}`           |

**Key takeaway:** The industry trend is toward *typed* identifiers. RFC 9493 explicitly
acknowledges that a simple string is insufficient for cross-domain subject identification.
However, this level of complexity is beyond what a minimal token needs.

References:
- [RFC 9493](https://datatracker.ietf.org/doc/html/rfc9493)

## 5. CWT `sub` (RFC 8392)

CWT mirrors JWT claims using integer keys for compactness. The `sub` claim (key `2`) is
a CBOR text string with no additional format constraints. Same semantics as JWT.

## 6. PASETO `sub`

PASETO's registered `sub` claim is a JSON string with no format constraints. Example:
`{"sub":"test"}`. Same open-ended approach as JWT.

## 7. JWT `aud` Claim

**Format:** `StringOrURI` (single string) or array of `StringOrURI` values. Any value
containing `:` must be a valid URI.

**In practice:**
- OAuth 2.0: typically a URL identifying the resource server (e.g., `"https://api.example.com"`)
- Auth0: API identifier, often a URL
- Google: the OAuth client_id string
- Microsoft: the application ID (a GUID)
- Internal systems: often a service name string

**Validation:** If present, the recipient must reject the token unless it finds its own
identifier in the `aud` value.

**Key takeaway:** `aud` is almost always a single value in practice (not an array).
The format varies: URLs, GUIDs, and plain strings are all common.

References:
- [RFC 7519 Section 4.1.3](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3)

## 8. UUID-Based Subjects

**Systems using fixed-length UUIDs:**
- Microsoft Entra `oid` claim: GUID (UUID) identifying user across applications
- Kubernetes service account UIDs
- Many internal systems use UUIDv4 for user IDs in databases

**UUID properties:**
- 128 bits (16 bytes binary, 36 chars as text with hyphens)
- Globally unique without coordination (UUIDv4 = 122 random bits)
- Standardized format (RFC 9562)
- No inherent meaning -- requires lookup table
- UUIDv7: time-ordered, sortable, still 16 bytes

---

## Tradeoff Analysis for protoken-rs

### Option A: Fixed-Length UUID (16 bytes)

```
Wire format: [ ...existing fields... | 16-byte subject | 16-byte audience ]
```

**Pros:**
- Predictable token size (adds exactly 32 bytes for sub + aud)
- Simple parsing: no length prefixes needed
- Aligns with protoken's fixed-layout philosophy
- Sufficient for most internal service-to-service use cases
- Can represent UUIDv4 (random), UUIDv7 (time-ordered), or any 128-bit identifier
- Many real-world systems already use UUIDs for user IDs

**Cons:**
- Cannot represent email addresses, URLs, or human-readable strings
- Requires a mapping layer: the verifier needs a UUID-to-identity lookup
- Incompatible with OIDC `sub` values (which are opaque strings of varying length)
- Cannot be used to directly carry Google's numeric `sub` or Auth0's `provider|id` format
- Difficult to adopt if existing system uses string-based identifiers

### Option B: Length-Prefixed Variable-Length Strings

```
Wire format: [ ...existing fields... | 1-byte sub_len | sub_bytes | 1-byte aud_len | aud_bytes ]
```

**Pros:**
- Can carry any identifier format: UUIDs, emails, URLs, opaque strings
- Compatible with OIDC/JWT `sub` values directly (no translation)
- Human-readable when inspected
- More flexible for diverse deployment scenarios
- A 1-byte length prefix supports up to 255 bytes, matching OIDC's max `sub` length

**Cons:**
- Variable token size (harder to reason about buffer sizes)
- Requires length prefixes (2 extra bytes for sub + aud)
- Parsing is slightly more complex
- Larger tokens for string identifiers vs binary UUIDs
- Strings invite encoding questions (must mandate UTF-8)
- Empty strings need a convention (0 length = absent?)

### Option C: Typed Identifier (1-byte type tag + value)

```
Wire format: [ 1-byte type | value ]
Types: 0x00 = absent, 0x01 = UUID (16 bytes), 0x02 = string (1-byte len + bytes)
```

**Pros:**
- Supports both compact UUIDs and flexible strings
- Self-describing: parser knows the format from the type byte
- Absent type avoids wasting bytes when claim is unused

**Cons:**
- More complex wire format
- Multiple code paths for serialization/deserialization
- Increases surface area for parsing bugs (security concern)
- Over-engineering for a minimal token format

### Size Comparison

| Scenario                    | Option A (UUID) | Option B (String)      | Option C (Typed) |
|-----------------------------|-----------------|------------------------|------------------|
| No sub/aud                  | 32 bytes wasted | 2 bytes (empty lens)   | 2 bytes (absent) |
| UUID sub + UUID aud         | 32 bytes        | 36 bytes (with lens)   | 34 bytes         |
| Email sub + URL aud         | N/A             | 2 + ~20 + ~30 = ~52 B | ~53 B            |
| Current HMAC token (51 B)   | +32 = 83 B     | +2 to +512 = 53-563 B | +2 to +514 B    |

### Recommendation

**Use length-prefixed variable-length bytes (Option B), but with these constraints:**

1. **Bytes, not strings.** Define `sub` and `aud` as opaque byte sequences, not UTF-8
   strings. This allows UUIDs (16 raw bytes), strings (UTF-8 encoded), or any other
   format. The interpretation is application-defined, matching JWT/CWT semantics.

2. **1-byte length prefix.** Supports 0-255 bytes. A length of 0 means the claim is
   absent. This matches OIDC's 255-char max for `sub`.

3. **No type tag.** Keep it simple. The token format does not dictate whether the value
   is a UUID, email, or URL -- that is the application's concern.

**Rationale:**
- Protoken aims to be a general-purpose token replacement, not just for UUID-based
  internal systems. Restricting to UUIDs would limit adoption.
- The OIDC ecosystem (Google, Microsoft, Auth0) uses variable-length string identifiers.
  Supporting these natively avoids requiring a translation layer.
- The size overhead of length prefixes (2 bytes total) is negligible.
- A binary opaque-bytes approach still allows compact 16-byte UUIDs when desired.
- The convention "0 length = absent" avoids wasting space when claims are unused,
  and it sidesteps the need for optional/typed fields.
- This approach mirrors CWT's design: `sub` and `aud` are simple values with
  application-defined semantics.

**Wire format impact:**
```
Version 1 payload:
[ 0x01 | algo | key_id_type | key_id | 8-byte expires_at | 1-byte sub_len | sub | 1-byte aud_len | aud ]
```

Token sizes with this approach:
| Configuration                 | Payload | Signature | Total  |
|-------------------------------|---------|-----------|--------|
| HMAC + key_hash, no sub/aud   | 21 B    | 32 B      | 53 B   |
| HMAC + key_hash, UUID sub only| 38 B    | 32 B      | 70 B   |
| Ed25519 + key_hash, both UUIDs| 53 B    | 64 B      | 117 B  |
| Ed25519 + key_hash, email+URL | ~71 B   | 64 B      | ~135 B |

Still well below JWT sizes (~300-400 B) in all cases.

## References

- [RFC 7519 - JSON Web Token](https://datatracker.ietf.org/doc/html/rfc7519)
- [RFC 7523 - JWT Profile for OAuth 2.0](https://www.rfc-editor.org/rfc/rfc7523.html)
- [RFC 8392 - CBOR Web Token](https://datatracker.ietf.org/doc/html/rfc8392)
- [RFC 9493 - Subject Identifiers for Security Event Tokens](https://datatracker.ietf.org/doc/html/rfc9493)
- [RFC 9562 - UUIDs](https://www.rfc-editor.org/rfc/rfc9562.html)
- [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
- [SAML 2.0 Core](http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf)
- [PASETO Claims Spec](https://github.com/paseto-standard/paseto-spec/blob/master/docs/02-Implementation-Guide/04-Claims.md)
- [Google OIDC](https://developers.google.com/identity/openid-connect/openid-connect)
- [Microsoft ID Token Claims](https://learn.microsoft.com/en-us/entra/identity-platform/id-token-claims-reference)
- [Auth0 Tokens](https://auth0.com/docs/secure/tokens)
- [SAML Subject ID Attributes v1.0](https://docs.oasis-open.org/security/saml-subject-id-attr/v1.0/cs01/saml-subject-id-attr-v1.0-cs01.html)
